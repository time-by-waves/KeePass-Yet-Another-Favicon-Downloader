# Security Audit: KeePass “Yet Another Favicon Downloader” (YAFD) Fork

## Overview and Network Interactions

**Plugin Functionality:** YAFD is a KeePass plugin that retrieves website favicons for password entries. It operates by reading each entry’s URL (or title if URL is empty, per user setting) and then fetching the favicon from the corresponding website or a chosen provider. By design, this involves outbound network requests from the KeePass client.

**Network Requests:** In default mode, YAFD attempts to download the icon directly from the site in the entry’s URL. It will perform an HTTP(S) GET to the target domain, first trying HTTPS and falling back to HTTP if configured to do so. The plugin parses the fetched HTML for any `<link rel="icon">` tags and downloads the referred icon files; if none are found, it falls back to requesting the site’s `/favicon.ico` URL. YAFD also supports **third-party “favicon provider” services** (e.g. DuckDuckGo, Google) – if the user selects one, the plugin constructs a URL template with the entry’s domain and downloads the icon from that service instead.

**Update Checks:** Additionally, the plugin includes an auto-update mechanism. On initialization it defines an update URL pointing to the original author’s GitHub repository (raw `VERSION` file) and an embedded RSA public key for signature verification. If KeePass’s plugin update check runs, YAFD may fetch this remote file to see if a new version is available, ensuring it’s signed by the author’s key.

## Credential and Data Exposure Risks

**URLs and Potential Credential Leakage:** The plugin does not directly access or transmit any KeePass passwords or user secrets; it only uses the entry’s URL field (and Title if configured). However, if **credentials are embedded in the URL** (for example, a URL like `https://user:password@host/path`), YAFD will include them in the request. In fact, the code’s logic explicitly preserves `username:password@` in the URL when forming requests. This means those credentials would be sent to the target host as part of the HTTP(S) request (likely as HTTP Basic Auth). While this is intended behavior for sites that require HTTP auth for the favicon, it **exposes those credentials over the network**. If the connection is not encrypted or if the URL was mistakenly pointed at an unintended host, this could leak sensitive info. **Recommendation:** Avoid storing credentials in the URL field where possible. If basic-auth credentials are needed for a site’s icon, ensure you trust the connection and domain. As a code mitigation, the plugin could be adjusted to strip out userinfo and handle authentication separately, but currently it does not.

**Entry Data Sent to External Services:** When using a third-party favicon service (DuckDuckGo, Google, etc.), the plugin will send the domain name of each entry to that service in order to retrieve the icon. For example, with the Google provider, it calls `https://www.google.com/s2/favicons?domain={URL:HOST}&sz=128` (with the entry’s host substituted). This **reveals the list of domains in your password database** to an external provider, which is a privacy consideration. The plugin’s UI explicitly requires the user to **opt-in and accept a warning** before using third-party providers (the “I accept” checkbox in the provider selection dialog) – acknowledging that using them will send data externally. **Recommendation:** Use the default direct method for maximum privacy, or host your own favicon service. If third-party services are used, be aware you are disclosing which sites you have credentials for. In sensitive environments, it may be best to keep this feature off (the default “None (Default)” provider means icons are fetched from the sites themselves, not a third party).

**HTTP vs HTTPS:** YAFD prefers HTTPS when fetching icons but can fall back to HTTP in some cases. Notably, if an entry URL has no scheme and the user enabled “Auto prefix URLs with https/http”, the plugin will try HTTPS first, and if that fails (e.g. TLS handshake issues or site doesn’t support SSL), it will retry with HTTP. An HTTP connection could allow an eavesdropper to see the domain and any URL path being requested (and if credentials were in the URL, those as well). However, YAFD will **not** downgrade an explicitly HTTPS URL to HTTP (it only downgrades if the scheme was initially absent). **Recommendation:** Leave the “Automatic prefix” option off unless needed (it’s off by default), and prefer explicit “https\://” in your entry URLs. This avoids unintended cleartext requests. If a site has an invalid SSL cert or old protocol, consider handling it manually rather than allowing an HTTP fallback when security is a concern.

**Proxy Usage:** The plugin respects KeePass’s proxy settings. It uses a reflective call to KeePass’s internal `IOConnection.GetWebProxy` to obtain the user’s configured proxy and applies it to all WebClient requests. This means outbound requests will go through your proxy if one is set in KeePass, which is good for corporate environments and for monitoring traffic. No credentials for the proxy appear to be handled in code (KeePass likely returns a fully formed `IWebProxy` object that handles any proxy auth). This “hack” ensures consistency with KeePass’s settings. From a security perspective, using the proxy is positive (no proxy bypass), though using reflection to get it is a bit unorthodox (not a vulnerability per se, but could break if KeePass internal API changes).

## Code Safety and Dependencies

**Third-Party Libraries:** This forked codebase does **not include external libraries** beyond the KeePass plugin API and the .NET framework. Networking is done via .NET’s `WebClient/HttpWebRequest`, and image processing via GDI+ (`System.Drawing`). There are no bundled scripts or additional binaries. This reduces the attack surface to mainly what .NET itself might be vulnerable to. It’s wise to keep your .NET Framework updated (on Windows, .NET 4.8) because image parsing and network stacks do get security updates. The plugin itself attempts to enable modern TLS support (up to TLS 1.3) by configuring `ServicePointManager.SecurityProtocol` on startup. (This is copied from KeePass 2.46’s approach to allow TLS 1.1+ on older .NET.) However, note it **also enables SSL3 and TLS1.0** in that protocol list. Those older protocols are insecure; their inclusion means if a server only supports SSL3/TLS1.0, the plugin can still connect. In theory, this could allow a downgrade attack if a malicious actor intercepted traffic and forced a weaker protocol. In practice, most servers won’t require falling back that far, and the TLS handshake will choose the highest common version. **Recommendation:** If you are in a controlled environment, you might disable legacy protocols machine-wide. For the plugin authors, a future improvement could be to drop SSL3 support, as it’s largely obsolete. As it stands, this is more of a compatibility consideration than an immediate “credential leak” risk, but it’s a security posture issue (using stronger protocols where possible).

**Error Handling & Unexpected Data:** The code has reasonable error handling. If an icon isn’t found or a network error occurs, it catches exceptions and records a “Not Found” or error status internally rather than propagating sensitive info. The plugin only stores the downloaded icon bytes in memory and then into the KeePass database as a custom icon. There’s no evidence of it writing any sensitive data to disk or logs. (Debug log messages exist – e.g., it logs “Downloading: URL” – but those are wrapped in `#if DEBUG` and thus absent in release builds.) The only persistent changes it makes are adding the icons to the database and (by default) updating the entry’s last-modified timestamp when an icon is added. This latter behavior might be “unexpected” to some users, but it’s a documented feature (you can disable the “Update entry last modification time” setting in the plugin’s menu). From a security standpoint, altering the timestamp is low-risk – just something to be aware of if you rely on those timestamps.

**Suspicious or Malicious Code:** Our review did **not find any backdoors or overtly malicious code** in this fork. The forked repository appears to match the upstream in functionality. The presence of the RSA public key and update URL is actually a good sign (the plugin will verify the authenticity of any update info from the author’s site). There is no code that attempts to read KeePass data beyond what’s needed (it doesn’t touch password fields, only URLs/titles and writes the icon to the entry). It also doesn’t open any connections other than the ones discussed (no hidden telemetry or extra domains aside from the update check and favicon fetches). All threads spawned are for the purpose of downloading icons concurrently. In short, the fork’s core logic aligns with expected functionality – no unexpected data is being sent out beyond the necessities of favicon retrieval.

## Security Risks Summary

1. **Disclosure of Entry URLs/Domains:** Using the plugin will expose the URLs or domain names of your KeePass entries to the internet – either directly to those websites or to a chosen third-party favicon service. This could be a privacy risk if, for example, you have entries for internal or secret services. An adversary monitoring network traffic might infer what services you use based on outbound requests. Mitigation: Use the plugin offline or on select entries, or refrain from using third-party providers. Ensure TLS is used (include `https://` in URLs) to encrypt the content of requests.

2. **Credentials in URLs:** If any entry’s URL contains embedded credentials or session tokens, these will be transmitted in the clear to the specified host (or potentially logged by that host) when the plugin fetches the page. Mitigation: Do not put sensitive query strings or user\:pass in the URL field unless absolutely required. If it’s needed for the favicon, consider changing your approach (e.g., use a placeholder URL for the favicon or retrieve it manually).

3. **Use of Insecure Protocols:** The plugin enables SSL 3.0/TLS 1.0 for compatibility, which could allow use of outdated crypto. Also, if “auto-prefix” is on, it might fall back to unencrypted HTTP. Mitigation: Keep auto-prefix off or carefully manage which entries you use it on. Generally, ensure you’re running KeePass on an up-to-date system so that even if older protocols are enabled, stronger ones take precedence. If you’re especially cautious, you can compile a custom version of the plugin with legacy SSL removed.

4. **External Service Trust:** If using DuckDuckGo/Google/Yandex for icons, you are trusting that service not to serve malicious data. The icon files are images that get processed by System.Drawing; a deliberately malformed image could in theory exploit an unpatched GDI+ vulnerability. This risk is low and would require a compromised or rogue provider. Mitigation: Stick to the default mode (fetch icons from the sites themselves) or a provider you trust. Keep your .NET/GDI libraries updated. The plugin does catch exceptions loading images, but that won’t stop a serious exploitation at the library level – prevention (via updates) is key.

5. **Resource Usage & Denial of Service:** YAFD is built to handle batch icon downloads efficiently, but note that it will download potentially large files if a site’s “favicon” link points to a large image. It doesn’t enforce a strict size limit on downloads. An entry pointing to a huge file or many entries at once could consume considerable bandwidth or memory. In extreme cases, this could hang KeePass or cause high memory usage. This isn’t a data leak, but it’s a stability risk. Mitigation: Be mindful of what URLs you feed it. The plugin adds a 20s timeout on requests, which helps avoid hanging on slow servers. There’s also a max of 10 redirects to prevent infinite redirect loops.

## Recommendations

* **Review and Limit Usage:** Enable YAFD only if you need the convenience of favicon fetching. In high-security environments, any plugin introduces some risk, so weigh the benefit. If you do use it, prefer the default direct-download mode and run downloads for entries that have public URLs (e.g., mainstream websites) rather than highly sensitive or internal ones.

* **Avoid Third-Party Providers or Self-Host:** The built-in provider options (DuckDuckGo, Google, etc.) are convenient but send your data to third parties. If you require bulk icon downloads without hitting each site (to reduce traffic or if some sites are unreachable), consider self-hosting a favicon service. For instance, you could use an open-source favicon proxy on a server you control, and then set that as a “Custom URL” provider in YAFD. This way, you limit exposure of your domain list. If you use the public providers, use them sparingly and only after accepting the plugin’s warning prompt.

* **Keep Software Updated:** Ensure you have the latest version of this plugin (and KeePass). The fork in question should be updated with any upstream fixes – check the fork’s commit history or the original repo’s releases. Notably, recent KeePass versions might break plugin compatibility until the plugin is updated (e.g., an issue noted about KeePass 2.55 compatibility). Also keep your .NET framework updated to mitigate any known vulnerabilities in the networking or image-handling components.

* **Network Monitoring:** If you want to be certain what the plugin is doing, consider running KeePass with network monitoring when using YAFD. You should observe connections to the domains corresponding to your entries, or to the selected provider’s API. No other unexpected destinations should be contacted. This can reassure that the plugin isn’t leaking data elsewhere. So far, our code inspection backs this up – it sticks to the necessary calls.

* **Configuration Hardening:** Within YAFD’s settings (Tools → YAFD), you can disable “Automatic prefix URLs” and the timestamp update if those are not desired. It might also be prudent to clear the “Custom download provider” field (set it to None) when you’re not actively using a third-party service – the plugin only shows the “(Custom)” download menu when a provider URL is configured. If you never use that, keep it blank to avoid accidental use.

* **Code Improvements (for maintainers):** It’s worth suggesting a few security-oriented improvements to the plugin’s developers:

  * Remove or make optional the inclusion of **SSL 3.0** in the SecurityProtocol (it’s outdated). Modern TLS should suffice in almost all cases.
  * Consider **stripping credentials** from URLs or at least logging a warning if userinfo is present in a URL. Users might not realize these will be sent. Perhaps the plugin could prompt “This URL contains credentials which will be used for icon download. Proceed?”.
  * Potentially implement a **size limit** or **content-type check** when downloading icon files (e.g., skip if file is overly large or not an image). This would guard against edge cases where a site might serve something unexpected under the favicon link.
  * Continue to ensure any new third-party dependencies (if ever added) are scrutinized for security. Currently, with no extra dependencies, the attack surface is primarily the .NET runtime and the remote servers.

## Conclusion

The **security audit of the time-by-waves/Yet-Another-Favicon-Downloader fork** did not uncover any malicious or highly suspicious code. The plugin’s behavior is in line with its purpose: it makes outbound web requests to fetch images. The main risks involve **privacy leakage (domains of your entries)** and the **possibility of transmitting entry-related info** (like URL-embedded creds or queries) over the network. By using the plugin’s settings cautiously and limiting third-party integrations, you can mitigate most of these concerns. Always treat KeePass plugins with care – they run with the same privileges as KeePass itself – but in this case the code appears clean. The forked codebase contains no hardcoded secrets or overt vulnerabilities; our recommendations mostly focus on usage best practices and minor hardening steps to further reduce any unintended data exposure.

**Sources:**

* Excerpts from YAFD source showing network request logic and credential handling.
* YAFD provider list defining external services (DuckDuckGo, Google, etc.).
* Plugin configuration and update check implementation.
* Favicon download workflow reading entry URLs and fetching icons.
